{"version":3,"file":"index.js","sources":["../utils/sandboxService/types.ts","../utils/lib.ts","../utils/sandboxService/Service.ts","../utils/errorHandler.ts","../constants/index.ts","index.ts"],"sourcesContent":["import { ChainType } from '@portkey/types';\n// import { portkeyDidUIPrefix } from '../../constants';\n\nexport enum SandboxEventTypes {\n  getBalances = '@portkey/did-ui-sdk:getBalances',\n  // View\n  callViewMethod = '@portkey/did-ui-sdk:callViewMethod',\n  // Send\n  callSendMethod = '@portkey/did-ui-sdk:callSendMethod',\n  // getEncodedTx\n  getTransactionFee = '@portkey/did-ui-sdk:getTransactionFee',\n\n  initViewContract = '@portkey/did-ui-sdk:initViewContract',\n}\n\nexport enum SandboxErrorCode {\n  error,\n  success,\n} // 0 error 1 success\n\nexport type SandboxDispatchData = { code: SandboxErrorCode; message?: any };\n\nexport interface DispatchParam {\n  chainType: ChainType;\n  rpcUrl: string;\n  [x: string]: any;\n}\n","import EventEmitter from 'events';\nimport * as uuid from 'uuid';\n\nexport const eventBus = new EventEmitter();\n\nexport const isExtension = () => location.protocol === 'chrome-extension:';\n\nexport const randomId = () => uuid.v4().replace(/-/g, '');\n","import { DispatchParam, SandboxDispatchData, SandboxEventTypes } from './types';\nimport { randomId } from '../lib';\nimport { sleep } from '@portkey/utils';\n\nexport class SandboxEventService {\n  static async dispatch(event: SandboxEventTypes, data?: any, ele = 'sandbox') {\n    let iframe = document.getElementById(ele);\n    if (!iframe) {\n      await sleep(1000);\n      iframe = document.createElement('iframe');\n    }\n    const sid = randomId();\n    (iframe as any)?.contentWindow.postMessage(\n      {\n        event,\n        data: { ...data, sid },\n      },\n      '*',\n    );\n    return { event, sid };\n  }\n\n  static dispatchToOrigin(event: MessageEvent<any>, data?: SandboxDispatchData) {\n    event?.source?.postMessage({ ...data, eventName: event.data.event }, event.origin as any);\n  }\n\n  static listen({ event: eventName, sid }: { event: SandboxEventTypes; sid: string }): Promise<any> {\n    return new Promise((resolve) => {\n      window.addEventListener('message', (event) => {\n        if (event.data.eventName === eventName && event.data.sid === sid) resolve(event.data);\n      });\n    });\n  }\n  /**\n   *\n   * @param event SandboxEventTypes\n   * @param data when callView data is DispatchData, other any\n   * @param ele\n   * @returns\n   */\n  static async dispatchAndReceive(event: SandboxEventTypes, data?: DispatchParam, ele = 'sandbox') {\n    const dispatchKey = await SandboxEventService.dispatch(event, data, ele);\n    return SandboxEventService.listen(dispatchKey);\n  }\n}\n","import { ErrorInfo, OnErrorFunc } from '../types';\nimport { message } from 'antd';\n\nexport const verifyErrorHandler = (error: any) => {\n  // let _error = isVerifyApiError(error);\n  let _error: string;\n  if (error?.type) {\n    _error = error.type;\n  } else if (typeof error === 'string') {\n    _error = error;\n  } else {\n    _error = error?.message || error?.error?.message || 'Verify error';\n  }\n  return _error;\n};\n\nexport const handleError = (error: any) => {\n  return error?.error || error;\n};\n\nexport const handleErrorMessage = (error: any, errorText?: string) => {\n  error = handleError(error);\n  if (!error) return errorText;\n  if (typeof error === 'string') return error;\n  if (typeof error.message === 'string') return error.message;\n  return errorText;\n};\n\nexport const handleErrorCode = (error: any) => {\n  return handleError(error)?.code;\n};\n\nexport const contractErrorHandler = (error: any) => {\n  if (typeof error === 'string') return error;\n  return error?.Error?.Message || error?.message?.Message || error?.message || error?.Error;\n};\n\nexport const errorTip = (errorInfo: ErrorInfo, isShowTip?: boolean, onError?: OnErrorFunc) => {\n  const msgError = errorInfo?.error?.error?.message || errorInfo?.error?.message || errorInfo?.error;\n  if (isShowTip) msgError && message.error(msgError);\n  onError?.(errorInfo);\n};\n\nexport const getMissParams = (obj: object): string | undefined => {\n  let _key;\n  Object.entries(obj)\n    .reverse()\n    .map(([key, value]) => {\n      if (!value) _key = key;\n    });\n  return _key;\n};\n","import { aelf } from '@portkey/utils';\nexport const COMMON_PRIVATE = 'f6e512a3c259e5f9af981d7f99d245aa5bc52fe448495e0b0dd56e8406be6f71';\n\nexport const SECOND = 1000;\nexport const MINUTE = SECOND * 60;\nexport const HOUR = MINUTE * 60;\nexport const DAY = HOUR * 24;\n\nexport const commonAccount = aelf.getWallet(COMMON_PRIVATE);\nexport const portkeyDidUIPrefix = '@portkey/did-ui-sdk:';\n","import { SandboxEventTypes, SandboxEventService, SandboxErrorCode } from '../utils/sandboxService';\nimport { aelf } from '@portkey/utils';\nimport { FetchRequest } from '@portkey/request';\nimport { ContractBasic, getContractBasic } from '@portkey/contracts';\nimport { getMissParams, handleErrorMessage } from '../utils/errorHandler';\nimport { COMMON_PRIVATE } from '../constants';\n\ntype SendBack = (\n  event: MessageEvent<any>,\n  response?: {\n    code: SandboxErrorCode;\n    message?: any;\n    sid: string;\n    error?: any;\n  },\n) => void;\ntype RpcUrl = string;\ntype ContractAddress = string;\ntype FromAccountPrivateKey = string;\nconst contracts: Record<RpcUrl, Record<ContractAddress, ContractBasic>> = {};\nconst accountContracts: Record<RpcUrl, Record<FromAccountPrivateKey, Record<ContractAddress, ContractBasic>>> = {};\n\nclass SandboxUtil {\n  constructor() {\n    this.listener();\n  }\n\n  static callback(\n    event: MessageEvent<any>,\n    response?: {\n      code: SandboxErrorCode;\n      message?: any;\n      sid: string;\n    },\n  ) {\n    SandboxEventService.dispatchToOrigin(event, response);\n  }\n\n  listener() {\n    window.addEventListener('message', async function (event) {\n      switch (event.data.event) {\n        case SandboxEventTypes.callViewMethod:\n          SandboxUtil.callViewMethod(event, SandboxUtil.callback);\n          break;\n        case SandboxEventTypes.callSendMethod:\n          SandboxUtil.callSendMethod(event, SandboxUtil.callback);\n          break;\n        case SandboxEventTypes.getTransactionFee:\n          SandboxUtil.getTransactionFee(event, SandboxUtil.callback);\n          break;\n        case SandboxEventTypes.initViewContract:\n          SandboxUtil.initViewContract(event, SandboxUtil.callback);\n          break;\n        default:\n          break;\n      }\n    });\n  }\n\n  static async initViewContract(event: MessageEvent<any>, callback: SendBack) {\n    const data = event.data.data ?? {};\n    try {\n      const { rpcUrl, address, chainType } = data;\n      // TODO only support aelf\n      if (chainType !== 'aelf') {\n        return callback(event, {\n          code: SandboxErrorCode.error,\n          message: 'Not support',\n          sid: data.sid,\n        });\n      }\n      await SandboxUtil._getELFViewContract(rpcUrl, address);\n      return callback(event, {\n        code: SandboxErrorCode.error,\n        message: 'Not Support',\n        sid: data.sid,\n      });\n    } catch (error) {\n      console.log(error, 'initViewContract===error');\n    }\n  }\n\n  static async _getELFViewContract(rpcUrl: string, address: string, privateKey: string = COMMON_PRIVATE) {\n    let _contract = contracts?.[rpcUrl]?.[address];\n    if (!_contract) {\n      _contract = await getContractBasic({\n        contractAddress: address,\n        account: aelf.getWallet(privateKey),\n        rpcUrl,\n      });\n      if (!contracts?.[rpcUrl]) contracts[rpcUrl] = {};\n      contracts[rpcUrl][address] = _contract;\n    }\n    return _contract;\n  }\n\n  static async _getELFSendContract(rpcUrl: string, address: string, privateKey: string) {\n    let _contract = accountContracts?.[rpcUrl]?.[privateKey]?.[address];\n    if (!_contract) {\n      _contract = await getContractBasic({\n        contractAddress: address,\n        account: aelf.getWallet(privateKey),\n        rpcUrl,\n      });\n      if (!accountContracts?.[rpcUrl]) accountContracts[rpcUrl] = {};\n      if (!accountContracts?.[rpcUrl]?.[privateKey]) accountContracts[rpcUrl][privateKey] = {};\n      accountContracts[rpcUrl][privateKey][address] = _contract;\n    }\n\n    return _contract;\n  }\n\n  static async callViewMethod(event: MessageEvent<any>, callback: SendBack) {\n    const data = event.data.data ?? {};\n    try {\n      const { rpcUrl, address, methodName, paramsOption = '', chainType } = data;\n      if (!rpcUrl || !address || !methodName)\n        return callback(event, {\n          code: SandboxErrorCode.error,\n          message: 'Invalid argument',\n          sid: data.sid,\n        });\n      // TODO only support aelf\n      if (chainType !== 'aelf') {\n        return callback(event, {\n          code: SandboxErrorCode.error,\n          message: 'Not support',\n          sid: data.sid,\n        });\n      }\n      const contract = await SandboxUtil._getELFViewContract(rpcUrl, address);\n      const result = await contract?.callViewMethod(methodName, paramsOption);\n      if (result.error)\n        return callback(event, {\n          code: SandboxErrorCode.error,\n          error: result.error,\n          sid: data.sid,\n        });\n      callback(event, {\n        code: SandboxErrorCode.success,\n        message: result.data,\n        sid: data.sid,\n      });\n    } catch (error: any) {\n      callback(event, {\n        code: SandboxErrorCode.error,\n        message: error?.error || error,\n        sid: data.sid,\n      });\n    }\n  }\n\n  static async callSendMethod(event: MessageEvent<any>, callback: SendBack) {\n    const data = event.data.data ?? {};\n\n    try {\n      const { rpcUrl, address, methodName, privateKey, paramsOption, chainType, isGetSignTx = 0, sendOptions } = data;\n      const missParams = getMissParams({\n        rpcUrl,\n        address,\n        methodName,\n      });\n      if (missParams)\n        return callback(event, {\n          code: SandboxErrorCode.error,\n          message: `Miss Param: ${missParams}`,\n          sid: data.sid,\n        });\n      // TODO only support aelf\n      if (chainType !== 'aelf') {\n        return callback(event, {\n          code: SandboxErrorCode.error,\n          message: 'Not support',\n          sid: data.sid,\n        });\n      }\n      const account = aelf.getWallet(privateKey);\n      const contract = await SandboxUtil._getELFSendContract(rpcUrl, address, privateKey);\n      const contractMethod = !isGetSignTx ? contract?.callSendMethod : contract?.encodedTx;\n      const req = await contractMethod?.(methodName, account, paramsOption, sendOptions);\n      if (req?.error)\n        return callback(event, {\n          code: SandboxErrorCode.error,\n          message: req.error?.message,\n          sid: data.sid,\n          error: req.error,\n        });\n      return callback(event, { code: SandboxErrorCode.success, message: req?.data, sid: data.sid });\n    } catch (e: any) {\n      callback(event, {\n        code: SandboxErrorCode.error,\n        message: handleErrorMessage(e),\n        sid: data.sid,\n      });\n    }\n  }\n\n  static async getTransactionFee(event: MessageEvent<any>, callback: SendBack) {\n    const data = event.data.data ?? {};\n    try {\n      const { rpcUrl, address, paramsOption, chainType, methodName, privateKey } = data;\n      // TODO only support aelf\n      if (chainType !== 'aelf') throw 'Not support';\n      const aelfInstance = aelf.getAelfInstance(rpcUrl);\n      const aelfContract = await SandboxUtil._getELFSendContract(rpcUrl, address, privateKey);\n      const raw = await aelf.encodedTx({\n        instance: aelfInstance,\n        contract: aelfContract,\n        functionName: methodName,\n        paramsOption,\n      });\n      if (raw.error) throw raw.error;\n      const customFetch = new FetchRequest({});\n\n      const transaction: any = await customFetch.send({\n        url: `${rpcUrl}/api/blockChain/calculateTransactionFee`,\n        method: 'POST',\n        params: {\n          RawTransaction: raw,\n        },\n      });\n\n      if (!transaction?.Success) throw 'Transaction failed';\n      callback(event, {\n        code: SandboxErrorCode.success,\n        message: transaction.TransactionFee,\n        sid: data.sid,\n      });\n    } catch (e) {\n      return callback(event, {\n        code: SandboxErrorCode.error,\n        message: e,\n        sid: data.sid,\n      });\n    }\n  }\n}\n\nnew SandboxUtil();\n"],"names":["SandboxEventTypes","getBalances","callViewMethod","callSendMethod","getTransactionFee","initViewContract","SandboxErrorCode","i","error","success","EventEmitter","SandboxEventService","static","event","data","ele","iframe","document","getElementById","sleep","createElement","sid","uuid","v4","replace","contentWindow","postMessage","source","eventName","origin","Promise","resolve","window","addEventListener","dispatchKey","dispatch","listen","handleErrorMessage","errorText","handleError","message","COMMON_PRIVATE","aelf","getWallet","contracts","accountContracts","SandboxUtil","constructor","this","listener","response","dispatchToOrigin","async","callback","rpcUrl","address","chainType","code","_getELFViewContract","privateKey","_contract","getContractBasic","contractAddress","account","methodName","paramsOption","result","isGetSignTx","sendOptions","missParams","obj","_key","Object","entries","reverse","map","key","value","getMissParams","contract","_getELFSendContract","req","encodedTx","e","aelfInstance","getAelfInstance","aelfContract","raw","instance","functionName","transaction","FetchRequest","send","url","method","params","RawTransaction","Success","TransactionFee"],"mappings":"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"}